from pathlib import Path
from PIL import Image, ImageTk
import tkinter as tk
from tkinter import filedialog, messagebox, Scrollbar, Canvas
import torch
import os

# ğŸ”§ ê¸°ë³¸ ì„¤ì •
DEFAULT_WEIGHT_PATH = "runs/train/ignition_yolo_final_retrain2/weights/best.pt"
IMG_DISPLAY_SIZE = (800, 600)
ZOOM_STEPS = [0.5, 1.0, 1.5, 2.0]

# yolov5 ë‚´ë¶€ ëª¨ë“ˆ ì„í¬íŠ¸
from utils.datasets import LoadImages
from utils.general import (
    check_img_size, non_max_suppression, scale_coords, cv2, increment_path
)
from utils.torch_utils import select_device
from models.common import DetectMultiBackend


class FireDetectionApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Ignition Point Detector [ì¸ì²œì†Œë°©]")
        self.image_paths = []
        self.image_index = 0
        self.zoom_index = 1  # 1.0ë°° ê¸°ë³¸

        # ğŸ”· ìƒë‹¨ ë¡œê³  + í…ìŠ¤íŠ¸ ì˜ì—­
        header_frame = tk.Frame(root, bg="white")
        header_frame.grid(row=0, column=0, columnspan=6, pady=(10, 5), sticky="w")

        try:
            logo_img = Image.open("logo.png").resize((200, 60))
            self.logo_tk = ImageTk.PhotoImage(logo_img)
            logo_label = tk.Label(header_frame, image=self.logo_tk, bg="white")
            logo_label.pack(side="left", padx=(10, 5))
        except Exception as e:
            print("ë¡œê³  ì´ë¯¸ì§€ ë¡œë”© ì‹¤íŒ¨:", e)

        title_label = tk.Label(
            header_frame,
            text="Ignition Point Detector [ì¸ì²œì†Œë°©]  v1.6.0",
            font=("ë§‘ì€ ê³ ë”•", 18, "bold"),
            fg="blue",
            bg="white"
        )
        title_label.pack(side="left", padx=10)

        # ğŸ–¼ï¸ ì´ë¯¸ì§€ í‘œì‹œ ì˜ì—­ (ìŠ¤í¬ë¡¤ í¬í•¨)
        self.canvas = Canvas(root, bg="white", width=850, height=650)
        self.scroll_x = Scrollbar(root, orient="horizontal", command=self.canvas.xview)
        self.scroll_y = Scrollbar(root, orient="vertical", command=self.canvas.yview)
        self.canvas.configure(xscrollcommand=self.scroll_x.set, yscrollcommand=self.scroll_y.set)
        self.canvas.grid(row=1, column=0, columnspan=5)
        self.scroll_x.grid(row=2, column=0, columnspan=5, sticky="ew")
        self.scroll_y.grid(row=1, column=5, sticky="ns")

        # ğŸ”˜ ë²„íŠ¼
        btn_style = {"bg": "blue", "fg": "white", "font": ("ë§‘ì€ ê³ ë”•", 12, "bold")}
        tk.Button(root, text="ì´ë¯¸ì§€ ì„ íƒ ë° ë¶„ì„", command=self.select_and_detect_images, **btn_style).grid(row=3, column=0, pady=10)
        tk.Button(root, text="â† ì´ì „", command=self.prev_image, **btn_style).grid(row=3, column=1)
        tk.Button(root, text="ë‹¤ìŒ â†’", command=self.next_image, **btn_style).grid(row=3, column=2)
        tk.Button(root, text="ï¼‹ í™•ëŒ€", command=self.zoom_in, **btn_style).grid(row=3, column=3)
        tk.Button(root, text="ï¼ ì¶•ì†Œ", command=self.zoom_out, **btn_style).grid(row=3, column=4)

    def select_and_detect_images(self):
        file_paths = filedialog.askopenfilenames(title="ì´ë¯¸ì§€ ì„ íƒ", filetypes=[("Image files", "*.jpg *.jpeg *.png")])
        if not file_paths:
            return

        weights = DEFAULT_WEIGHT_PATH if os.path.exists(DEFAULT_WEIGHT_PATH) else filedialog.askopenfilename(
            title="ê°€ì¤‘ì¹˜ íŒŒì¼ ì„ íƒ", filetypes=[("Model weights", "*.pt")]
        )
        if not weights or not os.path.exists(weights):
            messagebox.showerror("ì˜¤ë¥˜", "ê°€ì¤‘ì¹˜ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return

        device = select_device('')
        model = DetectMultiBackend(weights, device=device)
        stride, names = model.stride, model.names
        imgsz = check_img_size(640, s=stride)
        save_dir = increment_path(Path("runs/fire_detect"), exist_ok=False)
        os.makedirs(save_dir, exist_ok=True)

        self.image_paths.clear()
        self.zoom_index = 1

        for file_path in file_paths:
            dataset = LoadImages(file_path, img_size=imgsz, stride=stride)
            for path, im, im0s, _ in dataset:
                im = torch.from_numpy(im).to(device)
                im = im.float() / 255.0
                if im.ndimension() == 3:
                    im = im.unsqueeze(0)
                pred = model(im)
                pred = non_max_suppression(pred, conf_thres=0.25, iou_thres=0.45)

                for i, det in enumerate(pred):
                    im0 = im0s.copy()
                    if len(det):
                        det[:, :4] = scale_coords(im.shape[2:], det[:, :4], im0.shape).round()
                        for *xyxy, conf, cls in reversed(det):
                            label = f"{names[int(cls)]} {conf:.2f}"
                            cv2.rectangle(im0, (int(xyxy[0]), int(xyxy[1])), (int(xyxy[2]), int(xyxy[3])), (0, 0, 255), 2)
                            cv2.putText(im0, label, (int(xyxy[0]), int(xyxy[1]) - 10),
                                        cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
                    save_path = os.path.join(save_dir, os.path.basename(path))
                    cv2.imwrite(save_path, im0)
                    self.image_paths.append(save_path)

        self.image_index = 0
        if self.image_paths:
            self.show_image()

    def show_image(self):
        if not self.image_paths:
            return
        image_path = self.image_paths[self.image_index]
        img = Image.open(image_path)
        zoom = ZOOM_STEPS[self.zoom_index]
        img = img.resize((int(IMG_DISPLAY_SIZE[0]*zoom), int(IMG_DISPLAY_SIZE[1]*zoom)))
        self.tk_img = ImageTk.PhotoImage(img)
        self.canvas.delete("all")
        self.canvas.create_image(0, 0, anchor="nw", image=self.tk_img)
        self.canvas.config(scrollregion=self.canvas.bbox("all"))

    def next_image(self):
        if self.image_paths and self.image_index < len(self.image_paths) - 1:
            self.image_index += 1
            self.show_image()

    def prev_image(self):
        if self.image_paths and self.image_index > 0:
            self.image_index -= 1
            self.show_image()

    def zoom_in(self):
        if self.zoom_index < len(ZOOM_STEPS) - 1:
            self.zoom_index += 1
            self.show_image()

    def zoom_out(self):
        if self.zoom_index > 0:
            self.zoom_index -= 1
            self.show_image()


# GUI ì‹¤í–‰
if __name__ == "__main__":
    root = tk.Tk()
    app = FireDetectionApp(root)
    root.mainloop()
